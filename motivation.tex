\section{Motivation}
\label{sec:motivation}

Let's say someone implemented a clever algorithm, say \code{match}, for
regular expression matching. 
We do not trust this implementation and would like to test it.
Testing the implementation requires us to come up with test cases and
implement a test oracle, say \code{matchOracle}.

A test case consists of a regular expression \code{r} and an input
string \code{s}. Running the test means to execute \code{match r
  s} and check whether the result is correct by comparing with
\code{matchOracle r s}. But how do we know whether
\code{matchOracle} is correct, short of verifying it?

A popular way of conducting this test is using QuickCheck
\cite{quickcheck}, which performs property-based random testing. Using
QuickCheck, we would write a generator for regular expressions and then
use the generator for strings to generate many inputs for a
generated regular expression.

However, this approach has a
catch. Depending on the language of the regular expression, the
probability that a random string is a member of the language can be
severely skewed. As an example, consider the language $L = (ab)^*$ over the
alphabet $\Sigma = \{a, b\}$. Although $L$ contains infinitely many
words, the probability that a random word of
length $n$ is an element of $L$ is
\begin{itemize}
\item $0$ if $n$ is odd and
\item $\frac{1}{2^n}$ if $n$ is even.
\end{itemize}
Thus, the probability $p_n$ that a random word of length less than or equal to
$n$ is an element of $L$ is way smaller:
\begin{align*}
  p_n &= \frac{\lfloor n/2 \rfloor}{2^{n+1} - 1}
        \le \frac{n}{2^{n+2} - 2}
\end{align*}
Hence, the probability of (uniformly) randomly
selecting a word in $L$ is zero in the limit.

Wouldn't it be nice to have a systematic and obviously correct means
of generating words \textbf{inside} of $L$ and \textbf{outside} of
$L$? Such a generation algorithm would obviate the need for an oracle
and it would make sure that we can control the number of test inputs
in the language and in the language's complement.

\subsection{Research Question}
\label{sec:research-question}

\begin{figure}[tp]
  \begin{align*}
    r, s & &L(\_)=\quad &  &
                             \makebox[1em][l]{\code{data GRE sig}}\\
         & ::= \Rnull & \ltext{empty}
                        & \emptyset
                           &&\code{= Zero}\\
         & \mid \Rempty & \ltext{empty word}
                        & \{ \varepsilon \}
                           && \code{| One}\\
         & \mid (a \in \Sigma) & \ltext{singleton}
                        &  \{ a \}
                           && \code{| Atom sig} \\
         & \mid \Runion rs & \ltext{alternative}
                        &  L (r) \cup L (s)
                           && \code{| Or (GRE sig) (GRE sig)}\\
         & \mid \Rconcat rs & \ltext{concatenation}
                        &  L (r) \cdot L (s)
                           && \code{| Dot (GRE sig) (GRE sig)}\\
         & \mid \Rstar r & \ltext{Kleene star}
                        & (L (r))^* 
                           && \code{| Star (GRE sig)}\\
         & \mid \Rintersect rs & \ltext{intersection}
                        & L (r) \cap L (s)
                           && \code{| And (GRE sig) (GRE sig)}\\
         & \mid \Rcomplement r & \ltext{complement}
                        & \Sigma^* \setminus L (r)
                           && \code{| Not (GRE sig)}
  \end{align*}
  % \begin{align*}
  %   L (\Rnull) &= \emptyset\\
  %   L (\Rempty) &= \{ \varepsilon \} \\
  %   L (a) &= \{ a \} \\
  %   L (\Runion rs) &= L (r) \cup L (s) \\
  %   L (\Rconcat rs) &= L (r) \cdot L (s) \\
  %   L (\Rstar r) &= (L (r))^* \\
  %   L (\Rintersect rs) &= L (r) \cap L (s) \\
  %   L (\Rcomplement r) &= \Sigma^* \setminus L (r)
  % \end{align*}
  \caption{Generalized regular expressions}
  \label{fig:generalized-regular-expressions}
\end{figure}

We will look at a slightly more general question, which subsumes the
purpose of generating positive and negative sample words for
testing. A \emph{generalized regular expression}
(Figure~\ref{fig:generalized-regular-expressions}) is an expression
built from the regular operators empty set, empty word, singleton word
consisting of a single letter $a$ chosen from a finite alphabet
$\Sigma$, alternative, concatenation, and Kleene star. In addition, it
may contain the operators intersection and complement.

The semantics of an expression, $L(r) \subseteq \Sigma^*$, is a set of
words, which is also defined in
Figure~\ref{fig:generalized-regular-expressions}. It relies on
standard definitions from the theory of formal languages. We write
$\varepsilon$ for the empty word and $u\cdot v$ for the concatenation
of words $u, v \in \Sigma^*$. If $U, V \subseteq \Sigma^*$ are
languages, then their concatenation (or product) is defined as $U\cdot
V = \{ u\cdot v \mid u\in U, v\in V\}$. The Kleene closure of a
language $U\subseteq \Sigma^*$ is defined as $U^* =
\bigcup_{i=0}^\infty U^i$ where $U^0 = \{\varepsilon\}$ and $U^{i+i} =
U \cdot U^i$. 

\subsection{Naive Approach}
\label{sec:naive-approach}

We start with a naive implementation of the mathematical definition in
Figure~\ref{fig:generalized-regular-expressions}. We define an
alphabet by a list of \code{Char}.  We represent words by Haskell's
\code{Data.Text.Text} datatype, abbreviated to \code{T.Text}. We
represent a language as a lazy list of \code{Text}, as a language
can be an infinite set. There are two further restrictions.
\begin{enumerate}
\item The output of a generator should not contain repetitions
  because we would like to guarantee that test inputs are different
  from each others.
\item The output of a generator should not be partial because it would
  lead the test code to hang on a nonterminating input.
\end{enumerate}
\begin{lstlisting}
type Sigma = Char
type Lang = T.Text

generate :: Sigma -> GRE Char -> Lang
generate sigma r = gen r
  where
    gen Zero = []
    gen One  = [T.empty]
    gen (Atom t) = [T.singleton t]
    gen (Or r s) = union (gen r) (gen s)
    gen (Dot r s) = concatenate (gen r) (gen s)
    gen (Star r) = star (gen r)
    gen (And r s) = intersect (gen r) (gen s)
    gen (Not r) = complement sigma (gen r)

union, concatenate, intersect :: Lang -> Lang -> Lang
star :: Lang -> Lang
complement :: Sigma -> Lang -> Lang
\end{lstlisting}
Now we consider the operators in turn.

\subsubsection{Union}
Ideally, the \code{union} operator it should behave like
set union:
\begin{lstlisting}
w `elem` union xs ys   <==>   w `elem` xs || w `elem` ys
\end{lstlisting}
Can we implement \code{union} simply by list append?
No, we cannot. 
If \code{xs} is an infinite list and \code{ys} is different from
\code{xs}, then there is some \code{w `elem` ys} such that
\code{w `elem` union xs ys} does not terminate.
If \code{xs} is a finite list without duplicates, then simply
appending \code{ys} may result in duplicates.
Another alternative, \code{Data.List.union}, would apply only to finite lists.

Can we implement \code{union} by interleaving? No, we cannot for
similar reasons.

Our approach is to generate a language as a potentially infinite list
in ascending \emph{length-lexicographic order}. The
length-lexicographic ordering is defined by $u \lleq 
v$ if $|u|<|v|$ or $|u|=|v|$ and $u\le v$ in the usual lexicographic
ordering. Here is a definition in Haskell.
\begin{lstlisting}
lleq :: T.Text -> T.Text -> Bool
lleq u v =
  let lxs = T.length xs
      lys = T.length ys
  in  lxs < lys ||
      lxs == lys && xs <= ys
\end{lstlisting}
This ordering has the advantage that it gives raise to a standard
enumeration of all words over a totally ordered alphabet. In
particular, for each pair of words $u \lleq v$ there is only a finite
number of words $w$ such that $u \lleq w$ and $w \lleq v$. This property does
not hold for the lexicographic ordering where all elements of $a\cdot
(a+b)^*$ lie between words $a$ and $b$ (assuming $\Sigma = \{a, b\}$
with $a<b$).

With the LLO representation, the \code{union} operation can be
implemented by merging two lazy lists.
\begin{lstlisting}
union :: Lang -> Lang -> Lang
union [] ys = ys
union xs [] = xs
union xs@(x:xs') ys@(y:ys')
  | x == y   = x : union xs' ys'
  | lleq x y = x : union xs' ys
  | otherwise  = y : union xs ys'
\end{lstlisting}
Moreover, this operation runs in linear time. If the input languages
are finite of size $m$ and $n$, respectively, then $O(m+n)$
comparisons, pattern matches, and cons operations are needed.

This implementation fulfills the specification to a much larger
degree, but it still gets stuck on partial lists.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
