\section{Related Work}
\label{sec:related-work}

\subsubsection*{Regular Language Generation}
\citet{DBLP:journals/jfp/McIlroy04} implements the enumeration of
strings of regular languages in Haskell. He develops two approaches,
one based on interpreting regular expressions, the other using an
intermediate representation as a nondeterministic finite
automaton. The approach is inspired by an earlier note by Misra
\cite{misra11:_enumer_strin_regul_expres} and uses operators based on
an increasing list representation similar to our first proposal.

However, the approach does not consider the complement operation and
none of the presented representations can readily deal with
it. Moreover, the generation method is reported to be very inefficient
and thus not suitable for generating test inputs at a large scale.

\citet{DBLP:conf/wia/LeeS04} discuss enumerating regular expressions
and their languages. Despite the title, this work is unrelated
because it aims to find bounds on the number of languages that can be
represented with regular expressions and automata of a certain size.


\subsubsection*{Language Generation}
Some authors discuss the generation of test sentences from grammars for
exercising compilers
(e.g., \cite{DBLP:conf/cisse/ParachaF08,DBLP:conf/compsac/ZhengW09}
for some recent work). This
line of work goes back to Purdom's sentence generator for testing
parsers \cite{purdom72:_senten_gener_testin_parser}, which creates
sentences from a context-free grammar using each production at least
once.

Compared to our generator, the previous work starts from context-free
languages and aims at testing the apparatus behind the parser,
rather than the parser itself. Hence, it focuses on generating
positive examples, whereas we are also interested in counterexamples.

Grammar Testing~\cite{DBLP:conf/fase/Lammel01} aims to
identify and correct errors in a grammar by exercising it on example
sentences. The purpose is to recover ``lost'' grammars of programming
languages effectively.
Other work \cite{DBLP:conf/compsac/LiJLG04} also targets
testing the grammar, rather than the parser.

\subsubsection*{Test Data Generation}

Since the introduction of
QuickCheck~\cite{DBLP:conf/icfp/ClaessenH00}, property testing and
test-data generation has been used successfully in a wide variety of
contexts.  In property testing, input data for the function to test is
described via a set of combinators while the actual generation is
driven by a pseudo-random number generator. One difficulty of this
approach is to find the correct distribution of inputs that will
generate challenging test cases. This problem already arises with
recursive data types, but it is even more pronounced when generating
test inputs for regular expressions because, as explained in
\cref{sec:motivation}, many languages have a density of zero, which
means that a randomly generated word almost never belongs to the
langer.  Generating random \emph{regular expressions} is much
easier. We can thus combine property testing to generate regular
expressions and then apply our language generator to generate targeted
positive and negative input for these randomly generated regular
expressions.

\citet{DBLP:journals/jfp/NewFFM17} are concerned with the enumeration
of elements of various data structures. Their approach is
complementary to test-data generators. They exploit bijections between
natural numbers and the data domain and develop a quality criterion
for data generators based on a notion of fairness. It would be
interesting to investigate the connection between their enumeration
strategies and a direct representation of formal power series.

Crowbar~\cite{crowbar} is a library that combines property testing
with fuzzing.  In QuickCheck, the generation is driven by a random
number generator. Crowbar replaces this generator by
\texttt{afl-fuzz}~\cite{afl}. Afl is a fuzzer that relies on runtime
instrumentation to provide good code coverage, thus eliminating the
need to specify the distribution of random generators.  This approach,
however, is not sufficient to generate both regular expressions and
inputs, as we would still require an oracle. Our language generator
could allow to easily fuzz regular expression parsers.


% \subsubsection*{Testing Program Generators}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
