\section{Related Work}
\label{sec:related-work}

\subsubsection*{Regular Language Generation}
\citet{DBLP:journals/jfp/McIlroy04} implements the enumeration of
strings of regular languages in Haskell. He develops two approaches,
one based on interpreting regular expressions, the other using an
intermediate representation as a nondeterministic finite
automaton. The approach is inspired by an earlier note by Misra
\cite{misra11:_enumer_strin_regul_expres} and uses operators based on
an increasing list representation similar to our first proposal.

However, the approach does not consider the complement operation and
none of the presented representations can readily deal with
it. Moreover, the generation method is reported to be very inefficient
and thus not suitable for generating test inputs at a large scale.

\citet{DBLP:conf/wia/LeeS04} discuss enumerating regular expressions
and their languages. Despite the title, this work is unrelated
because it aims to find bounds on the number of languages that can be
represented with regular expressions and automata of a certain size.


\subsubsection*{Language Generation}
Some authors discuss the generation of test sentences from grammars for
exercising compilers
(e.g., \cite{DBLP:conf/cisse/ParachaF08,DBLP:conf/compsac/ZhengW09}
for some recent work). This
line of work goes back to Purdom's sentence generator for testing
parsers \cite{purdom72:_senten_gener_testin_parser}, which creates
sentences from a context-free grammar using each production at least
once.

Compared to our generator, the previous work starts from context-free
languages and aims at testing the apparatus behind the parser,
rather than the parser itself. Hence, it focuses on generating
positive examples, whereas we are also interested in counterexamples.

Grammar Testing~\cite{DBLP:conf/fase/Lammel01} aims to
identify and correct errors in a grammar by exercising it on example
sentences. The purpose is to recover ``lost'' grammars of programming
languages effectively.
Other work \cite{DBLP:conf/compsac/LiJLG04} also targets
testing the grammar, rather than the parser.

\subsubsection*{Test Data Generation}

Since the introduction of QuickCheck~\cite{DBLP:conf/icfp/ClaessenH00},
property testing and test-data generation has been used successfully in a
wide variety of contexts.
In property testing, input data for the function
to test is described via a set of combinators while the actual generation
is driven by a pseudo-random number generator. One difficulty of this approach is
to find the correct distribution of inputs that will generate challenging
test cases. This is particular troublesome for testing of regular expressions
since, as we highlighted in \cref{sec:motivation}, many languages
have a probability zero of being generated randomly.
Generating random \emph{regular expressions}, however, is much easier. We can
thus combine property testing to generate regular expression and applies
our language generator to these randomly generated regular expressions.

Crowbar~\cite{crowbar} is a library that combines property testing with fuzzing.
In QuickCheck, the generation is driven by a random number generator. Crowbar replaces this generator by \texttt{afl-fuzz}~\cite{afl}. Afl is a fuzzer that
relies on runtime instrumentation to provide
good code coverage, thus eliminating the need to specify the distribution of random generators.
This approach, however, is not sufficient to generate both regular expressions
and inputs, as we would still require an oracle. Our language generator
could allow to easily fuzz regular expression parsers.

% QuickCheck, Smallcheck
% Robby Findler

% \subsubsection*{Testing Program Generators}

% \subsubsection*{Fuzzing}


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
